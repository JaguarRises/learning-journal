I had an existing Scala backend service that:

Was written using Play Framework 2.x

Ran on Java 11

Used Akka internally

Used many sbt plugins (Kamon, Kubernetes, Docker, dotenv, etc.)

Your goal was:

Upgrade the project to Play 3 and Java 21, and make it build and compile successfully.

1Ô∏è‚É£ What are these tools? (Very basics)
1.1 Scala

Scala is a programming language that:

Runs on the JVM (like Java)

Is compiled before running

Uses types, implicits, and functional constructs

Your codebase is mostly Scala, with a bit of Java.

1.2 sbt (Scala Build Tool)

sbt is:

Like Maven/Gradle, but for Scala

Responsible for:

Downloading dependencies

Running the compiler

Running the app

Packaging Docker images

Applying plugins

Key files:

build.sbt ‚Üí project definition

project/plugins.sbt ‚Üí sbt plugins

project/build.properties ‚Üí sbt version

If sbt doesn‚Äôt start ‚Üí nothing else matters.

1.3 Play Framework

Play is a web framework:

Similar to Spring Boot

Provides:

HTTP routing

Controllers

Filters

Dependency Injection

JSON handling

Versions matter a LOT:
Play version	Internals
Play 2.x	Akka
Play 3.x	Pekko
Play 3.x	Jakarta APIs
Play 3.x	Java 17+ friendly

Play 3 is not backward-compatible with Play 2.

1.4 Akka vs Pekko (critical concept)

Akka was a toolkit for concurrency (actors, streams)

It moved to a restrictive license

Apache forked it as Pekko

Result:

Play 3 removed Akka

Play 3 uses Pekko

Same concepts, different package names

Old	New
akka.actor	org.apache.pekko.actor
akka.stream	org.apache.pekko.stream

This single change breaks a LOT of code.

1.5 Java 21

Java 21 is:

Much stricter than Java 8/11

Enforces module boundaries

Forbids unsafe reflection unless explicitly allowed

Anything that:

Hacks JVM internals

Modifies environment variables reflectively
‚Üí will break

2Ô∏è‚É£ What went wrong initially (root problems)

When you opened the project:

‚ùå sbt failed to build

Because:

Private dependencies needed credentials

sbt plugins couldn‚Äôt resolve

Old plugins were incompatible with new sbt

‚ùå Java 21 caused crashes

Because:

Some plugins used reflection to modify environment variables

Java 21 blocks that

‚ùå Play warned:
Play supports only Java 8, 11, and experimentally 17


This told us:

You are using technology beyond what this Play version was designed for

3Ô∏è‚É£ Step-by-step: what we fixed and WHY

Now the real explanation.

STEP 1: Fix sbt itself
What we did

Upgraded sbt to 1.9.9

Fixed plugin resolvers

Corrected Play plugin group ID

Why

If sbt can‚Äôt:

Resolve plugins

Load the project

üëâ Nothing else works

This is always step #1 in any Scala migration.

STEP 2: Remove broken sbt plugins
Plugins we removed (temporarily)

Kamon sbt plugin

JavaAgent plugin

Kubernetes plugin

dotenv plugin

Why

These plugins:

Were written for Play 2

Assumed Akka

Used illegal reflection on Java 21

Injected keys that no longer exist

Rule:

If a plugin prevents sbt from starting, it must go

We didn‚Äôt ‚Äúdelete functionality‚Äù ‚Äî we postponed it.

STEP 3: Fix enablePlugins(...)

Your build referenced plugins like:

KubernetesPlugin
JavaAgent


But those plugins were no longer loaded.

Result

Compiler error:

not found: value KubernetesPlugin

Fix

We removed them from enablePlugins.

Why?
Because:

sbt plugins define keys

No plugin ‚Üí no key ‚Üí compilation fails

STEP 4: First real Play 3 error (Base64)
The error
import akka.parboiled2.util.Base64

Why it broke

Akka is gone

parboiled2 via Akka is gone

Java already provides Base64

Fix

We replaced:

akka.parboiled2.util.Base64


with:

java.util.Base64

Important lesson

Prefer JDK APIs over framework utilities

They survive upgrades.

STEP 5: Akka ‚Üí Pekko type mismatch
The error
found: akka.stream.Materializer
required: org.apache.pekko.stream.Materializer

Why

Play 3 expects Pekko

Your code still imported Akka

Same class name, different type

Fix

We changed:

import akka.stream.Materializer


to:

import org.apache.pekko.stream.Materializer


This is the core Play 3 migration theme.

STEP 6: Compile succeeded üéâ

At this point:

sbt loads

Play 3 loads

Java 21 works

All Akka references encountered so far were fixed

No runtime plugins blocking startup

You reached:

[success] Total time: ...


This is the definition of a successful migration phase 1.

4Ô∏è‚É£ What functionality did we change?
‚ùå What we did NOT change

Business logic

Kafka consumers

Database logic

API behavior

JSON formats

Authentication logic (conceptually)

‚úÖ What we changed

Build system

Imports

Infrastructure wiring

Underlying concurrency engine

Base64 implementation

So your application behavior is logically the same, but the platform is modern.

5Ô∏è‚É£ Why all those WARNINGS appeared (and why they‚Äôre okay)

Examples:

Implicit definition should have explicit type


This happens because:

Scala 2.13 is stricter

Play 3 uses Scala 2.13+

Compiler now enforces best practices

They are:

Compile-time only

Non-breaking

Fixable later

Rule:

Never fix warnings during a migration unless they block compilation
